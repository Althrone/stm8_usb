/**Private typedef*************************************************************/
/* USER CODE BEGIN PT */
#include "crc.h"
// typedef enum
// {
// 	CRC5_USB,
// 	CRC16_USB,
//     CRC_NUM
// }CrcTypeE;
 
typedef enum
{
    E_FALSE = 0, //假（错误）
    E_TRUE = !E_FALSE //真（正确）
}BoolTypeE;
 
typedef struct
{
	char *Name;
    unsigned char Width; //宽度，即CRC比特数。
    unsigned int  Poly; //生成多项式的简写，以16进制表示。例如：CRC-32即是0x04C11DB7，忽略了最高位的"1"，即完整的生成项是0x104C11DB7。
    unsigned int  CrcInit; //初始值,这是算法开始时寄存器（crc）的初始化预置值，十六进制表示。
    unsigned int  XorOut; //计算结果与此参数异或后得到最终的CRC值。
    BoolTypeE RefIn; //待测数据的每个字节是否按位反转，E_TRUE或E_FALSE。
    BoolTypeE RefOut; //在计算后之后，异或输出之前，整个数据是否按位反转，E_TRUE或E_FALSE。
}CrcInfoTypeS;
/* USER CODE END PT */
 
 
/**Private variables***********************************************************/
/* USER CODE BEGIN PV */
const static CrcInfoTypeS s_crcInfoTab[CRC_NUM] =
{
    //CRC算法名称			宽度  多项式      初始值      结果异或值  输入反转    输出反转
    {"CRC5_USB", 			5,     0x05,       0x1F,       0x1F,       E_TRUE,   E_TRUE},
    {"CRC16_USB", 			16,    0x8005,     0xFFFF,     0xFFFF,     E_TRUE,   E_TRUE},
};
 
static unsigned int s_crcTab[2][256]=
{
    {//CRC5_USB
        0x00, 0x0E, 0x1C, 0x12, 0x11, 0x1F, 0x0D, 0x03, 0x0B, 0x05, 0x17, 0x19, 0x1A, 0x14, 0x06, 0x08,
        0x16, 0x18, 0x0A, 0x04, 0x07, 0x09, 0x1B, 0x15, 0x1D, 0x13, 0x01, 0x0F, 0x0C, 0x02, 0x10, 0x1E,
        0x05, 0x0B, 0x19, 0x17, 0x14, 0x1A, 0x08, 0x06, 0x0E, 0x00, 0x12, 0x1C, 0x1F, 0x11, 0x03, 0x0D,
        0x13, 0x1D, 0x0F, 0x01, 0x02, 0x0C, 0x1E, 0x10, 0x18, 0x16, 0x04, 0x0A, 0x09, 0x07, 0x15, 0x1B,
        0x0A, 0x04, 0x16, 0x18, 0x1B, 0x15, 0x07, 0x09, 0x01, 0x0F, 0x1D, 0x13, 0x10, 0x1E, 0x0C, 0x02,
        0x1C, 0x12, 0x00, 0x0E, 0x0D, 0x03, 0x11, 0x1F, 0x17, 0x19, 0x0B, 0x05, 0x06, 0x08, 0x1A, 0x14,
        0x0F, 0x01, 0x13, 0x1D, 0x1E, 0x10, 0x02, 0x0C, 0x04, 0x0A, 0x18, 0x16, 0x15, 0x1B, 0x09, 0x07,
        0x19, 0x17, 0x05, 0x0B, 0x08, 0x06, 0x14, 0x1A, 0x12, 0x1C, 0x0E, 0x00, 0x03, 0x0D, 0x1F, 0x11,
        0x14, 0x1A, 0x08, 0x06, 0x05, 0x0B, 0x19, 0x17, 0x1F, 0x11, 0x03, 0x0D, 0x0E, 0x00, 0x12, 0x1C,
        0x02, 0x0C, 0x1E, 0x10, 0x13, 0x1D, 0x0F, 0x01, 0x09, 0x07, 0x15, 0x1B, 0x18, 0x16, 0x04, 0x0A,
        0x11, 0x1F, 0x0D, 0x03, 0x00, 0x0E, 0x1C, 0x12, 0x1A, 0x14, 0x06, 0x08, 0x0B, 0x05, 0x17, 0x19,
        0x07, 0x09, 0x1B, 0x15, 0x16, 0x18, 0x0A, 0x04, 0x0C, 0x02, 0x10, 0x1E, 0x1D, 0x13, 0x01, 0x0F,
        0x1E, 0x10, 0x02, 0x0C, 0x0F, 0x01, 0x13, 0x1D, 0x15, 0x1B, 0x09, 0x07, 0x04, 0x0A, 0x18, 0x16,
        0x08, 0x06, 0x14, 0x1A, 0x19, 0x17, 0x05, 0x0B, 0x03, 0x0D, 0x1F, 0x11, 0x12, 0x1C, 0x0E, 0x00,
        0x1B, 0x15, 0x07, 0x09, 0x0A, 0x04, 0x16, 0x18, 0x10, 0x1E, 0x0C, 0x02, 0x01, 0x0F, 0x1D, 0x13,
        0x0D, 0x03, 0x11, 0x1F, 0x1C, 0x12, 0x00, 0x0E, 0x06, 0x08, 0x1A, 0x14, 0x17, 0x19, 0x0B, 0x05,
    },
    {//CRC16_USB
        0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
        0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
        0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
        0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
        0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
        0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
        0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
        0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
        0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
        0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
        0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
        0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
        0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
        0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
        0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
        0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040,
    },
};
/* USER CODE END PV */

/**
 *******************************************************************************
 * @brief   位反转 函数
 * @param   [in] inVal	- 反转前数据
 * @param   [in] bits   - 反转位数
 * @return  反转后数据
 * @note    就是将高位与低位数据顺序反过来。
 *******************************************************************************
 */
unsigned int BitsReverse(unsigned int inVal, unsigned char bits)
{
    unsigned int outVal = 0;
    unsigned char i;
    
    for(i=0; i<bits; i++)
    {  
        if(inVal & (1 << i)) outVal |= 1 << (bits - 1 - i);
    }
    
    return outVal;
}

 
/**
 *******************************************************************************
 * @brief   获取 CRC(循环冗余校验) 函数
 * @param   [in] type   - CRC 类型
 * @param   [in] *buf   - 数据块指针
 * @param   [in] bufLen - 数据长度
 * @return  校验码
 * @note    
 *******************************************************************************
 */
unsigned int GetCRC(CrcTypeE type, unsigned char *buf, unsigned int bufLen)
{
    unsigned char width  = s_crcInfoTab[type].Width; //宽度，即CRC比特数。
    unsigned int  crc    = s_crcInfoTab[type].CrcInit; //初始值,这是算法开始时寄存器（crc）的初始化预置值，十六进制表示。
    unsigned int  xorout = s_crcInfoTab[type].XorOut; //计算结果与此参数异或后得到最终的CRC值。
    unsigned char refin  = s_crcInfoTab[type].RefIn; //待测数据的每个字节是否按位反转，E_TRUE或E_FALSE。
    unsigned char refout = s_crcInfoTab[type].RefOut; //在计算后之后，异或输出之前，整个数据是否按位反转，E_TRUE或E_FALSE。
    unsigned char high;
 
    if(refin) //逆序 LSB 输入
    {
        crc = BitsReverse(crc, width); //init 先逆序;
        if(width > 8) //为了减少移位等操作，width大于8和小于8的分开处理
        {
            while(bufLen--)
            {
                crc = (crc >> 8) ^ s_crcTab[type][(crc & 0xFF) ^ *buf++];
            }
        }
        else
        {
            while(bufLen--)
            {
                crc = s_crcTab[type][crc ^ *buf++];
            }
        }
    }
    else //正序 MSB 输入
    {
        if(width > 8) //为了减少移位等操作，width大于8和小于8的分开处理
        {
            while (bufLen--)
            {
                high = crc >> (width - 8);
                crc = (crc << 8) ^ s_crcTab[type][high ^ *buf++];
            }
        }
        else
        {
            crc = crc << (8 - width);
            while (bufLen--)
            {
                crc = s_crcTab[type][crc ^ *buf++];
            }
            crc >>= 8 - width; //位数小于8时，crc在高width位，要右移到原位
        }
    }
 
    if(refout != refin) //逆序输出
    {
        crc = BitsReverse(crc, width);
    }
 
    crc ^= xorout; //异或输出
 
    return crc & ((2 << (width - 1)) - 1);
}